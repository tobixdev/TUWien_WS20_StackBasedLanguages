% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    /goto { advance advance goto }

    /if_icmplt { advance advance if_icmplt }
    /if_icmpge { advance advance if_icmpge }
    /ifeq { advance advance ifeq }

    /iload { advance iload }
    /iload_0 { 0 iload exec }
    /iload_1 { 1 iload exec }
    /iload_2 { 2 iload exec }
    /iload_3 { 3 iload exec }

    /iconst_m1 { -1 }
    /iconst_0 { 0 }
    /iconst_1 { 1 }
    /iconst_2 { 2 }
    /iconst_3 { 3 }
    /iconst_4 { 4 }
    /iconst_5 { 5 }

    /istore { istore }
    /istore_0 { 0 istore }
    /istore_1 { 1 istore }
    /istore_2 { 2 istore }
    /istore_3 { 3 istore }

    /iadd { iadd }
    /isub { isub }
    /idiv { idivision }
    /imul { imult }
    /i2l { i2l }
    /ishl { ishl }
    /ishr { ishr }
    % maybe implement airthmetic right shift "manually"?

    /lload { advance lload }
    /lload_0 { 0 lload exec }
    /lload_1 { 1 lload exec }
    /lload_2 { 2 lload exec }
    /lload_3 { 3 lload exec }

    /lconst_m1 { -1 }
    /lconst_0 { 0 }
    /lconst_1 { 1 }
    /lconst_2 { 2 }
    /lconst_3 { 3 }
    /lconst_4 { 4 }
    /lconst_5 { 5 }

    /l2i { l2i }
    
    /ireturn { ireturn }
    /lreturn { lreturn }
>> def

/load_inst_handler {
    userdict /instruction_handlers get exch 2 copy known not {
        (Encountered an unknown byte code instruction. Aborting.) print quit
    } if get
} def

/compile { % -> <code array>
    { /instructions [ } cvlit

    % Collect instruction_handlers in array on stack
    userdict /instructions get length
    /i 0 def
    {
        userdict /instructions get i get % load instruction or additional byte
        dup type (integertype) eq not { load_inst_handler } if % load handler if instruction
        wrap_in_array concat
        /i i 1 add def
    } repeat

    { ] def } cvlit concat % define instructions
    { define_variables_for_parameters } cvlit concat
    { { ip instructions length lt not { exit } if next } loop } cvlit concat % loop until ip is after the last instruction
    { = quit } cvlit concat % we end the program after execution
} def

/wrap_in_array { % a -> [ a ]
    [ exch ]
} def

/execute { % <program_arguments...> <argument_count> ->
    compile cvx exec
} def

/concat { % array1 array2 -> array1++array2
    /additional exch def
    /base exch def
    /new base length additional length add array def % create array
    new 0 base putinterval
    new base length additional putinterval
    new
} def