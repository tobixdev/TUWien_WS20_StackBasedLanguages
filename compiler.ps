% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    /goto { advance advance goto }

    /if_icmplt { advance advance if_icmplt }
    /if_icmpge { advance advance if_icmpge }
    /ifeq { advance advance ifeq }

    /iload { advance iload }
    /iload_0 { 0 iload exec }
    /iload_1 { 1 iload exec }
    /iload_2 { 2 iload exec }
    /iload_3 { 3 iload exec }

    /iconst_m1 { -1 }
    /iconst_0 { 0 }
    /iconst_1 { 1 }
    /iconst_2 { 2 }
    /iconst_3 { 3 }
    /iconst_4 { 4 }
    /iconst_5 { 5 }

    /istore { istore }
    /istore_0 { 0 istore }
    /istore_1 { 1 istore }
    /istore_2 { 2 istore }
    /istore_3 { 3 istore }

    /iadd { iadd }
    /isub { isub }
    /idiv { idivision }
    /imul { imult }
    /ishl { ishl }
    /ishr { ishr }
    % maybe implement airthmetic right shift "manually"?
    
    /ireturn { ireturn }
>> def

/load_inst_handler {
    userdict /instruction_handlers get exch 2 copy known not {
        (Encountered an unknown byte code instruction ') print print ('. Aborting.) print quit
    } if get
} def

/define_variables_for_parameters { % <input parameter> <parameter_count> ->
    % variables are numbered from <parameter_count> -1 -> 0
    dup 1 sub /pc_m1 exch def
    /i 0 def
    {
        userdict /variables get exch
        pc_m1 i sub
        exch put
        
        /i i 1 add def
    } repeat
} def

/compile { % -> <code array>
    /compiled_instructions [] def

    % Collect instruction_handlers in compiled_instructions
    userdict /instructions get length
    /i 0 def
    {
        userdict /instructions get i get dup type (integertype) eq not { load_inst_handler } if [ exch ] compiled_instructions exch concat
        /compiled_instructions exch def
        /i i 1 add def
    } repeat

    [ /instructions] [ compiled_instructions ] concat { def } concat % define instructions
    userdict /define_variables_for_parameters get concat % call define_variables_for_parameters at the beginning
    { { ip instructions length lt not { exit } if next } loop } concat % loop until ip is after the last instruction
    { = quit } concat % we end the program after execution

} def

/execute { % <program_arguments...> <argument_count> ->
    compile cvx exec
} def

/concat { % array1 array2 -> array1++array2
    cvlit
    /additional exch def
    /base exch def
    /new base length additional length add array def % create array
    new 0 base putinterval
    new base length additional putinterval
    new
} def