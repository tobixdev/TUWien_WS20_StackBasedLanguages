/variables <<
>> def

% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    (iload)   { 
        cvi //variables exch get
        dup type (integertype) eq not { (Loaded variable is no integer. Aborting.) print quit } if
    }
    (iadd)    { add }
    (ireturn) {}
>> def

/ip 0 def

/load_inst { % -> string
 instructions ip get
 /ip ip 1 add def 
} def

/next { % -> the semantics of the next instruction will be applied
    load_inst (_) search {
        exch pop
    } if
    //instruction_handlers exch 2 copy known not {
        (Encountered an unknown byte code instruction. Aborting.) print quit
    } if
    get exec
} def

/define_variables_for_parameters { % <input parameter> <parameter_count> ->
    /i 0 def
    {
        //variables exch i exch put
        /i i 1 add def
    } repeat
} def

/execute { % <input parameters> <paramter_count> -> <result>
    define_variables_for_parameters
    instructions length { next } repeat
} def

1 2 % parameters
2 % parameter count
execute
=
quit