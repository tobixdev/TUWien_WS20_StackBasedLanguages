/variables <<
>> def

/compiled [] def

% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    (goto) { advance advance goto }

    (if_icmplt) { advance advance if_icmplt }
    (if_icmpge) { advance advance if_icmpge }
    (ifeq) { advance advance ifeq }
    
    (iload) { advance iload }
    (iload_0) { 0 iload exec }
    (iload_1) { 1 iload exec }
    (iload_2) { 2 iload exec }
    (iload_3) { 3 iload exec }
    
    (iconst_m1) { -1 }
    (iconst_0) { 0 }
    (iconst_1) { 1 }
    (iconst_2) { 2 }
    (iconst_3) { 3 }
    (iconst_4) { 4 }
    (iconst_5) { 5 }
    
    (istore) { istore }
    (istore_0) { 0 istore }
    (istore_1) { 1 istore }
    (istore_2) { 2 istore }
    (istore_3) { 3 istore }
    
    (iadd) { iadd }
    (isub) { isub }
    (idiv) { idivision }
    (imul) { imult }

    (ishl) { ishl }
    (ishr) { ishr }
    % maybe implement airthmetic right shift "manually"?
    
    (ireturn) { ireturn }
>> def

/ip 0 def

/advance { % -> <value at ip>
    instructions ip get 
    /ip ip 1 add def 
} def

/load_inst_handler {
    userdict /instruction_handlers get exch 2 copy known not {
        (Encountered an unknown byte code instruction ') print print ('. Aborting.) print quit
    } if get
} def

/next { % -> the semantics of the next instruction will be applied
    advance exec 
} def

/define_variables_for_parameters { % <input parameter> <parameter_count> ->
    % variables are numbered from <parameter_count> -1 -> 0
    dup 1 sub /pc_m1 exch def
    /i 0 def
    {
        userdict /variables get exch
        pc_m1 i sub
        exch put
        
        /i i 1 add def
    } repeat
} def

/execute { % <input parameters> <paramter_count> -> <result>
    compile compiled cvx exec
} def

/compile {
    /compiled_instructions [] def

    % Collect instruction_handlers in compiled_instructions
    userdict /instructions get length
    /i 0 def
    {
        userdict /instructions get i get dup type (integertype) eq not { load_inst_handler } if [ exch ] compiled_instructions exch concat
        /compiled_instructions exch def
        /i i 1 add def
    } repeat

    /compiled
    
    [ /instructions] compiled concat [ compiled_instructions ] concat { def } concat % define instructions
    { /ip 0 def } concat % define IP
    { /variables << >> def } concat % define IP
    { /advance userdict /advance get def } concat % define advance
    { /next userdict /next get def } concat % define next
    userdict /define_variables_for_parameters get concat % define define_variables_for_parameters

    { { ip instructions length lt not { exit } if next } loop } concat % loop until ip is after the last instruction

    def

} def

/concat {
    cvlit
    /additional exch def
    /base exch def
    /new base length additional length add array def % create array
    new 0 base putinterval
    new base length additional putinterval
    new
} def