/variables <<
>> def

% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    (goto) { load_byte load_byte goto }
    (if_icmplt) { load_byte load_byte if_icmplt }
    (if_icmpge) { load_byte load_byte if_icmpge }
    (iload) { load_byte iload }
    (iload_0) { 0 iload exec }
    (iload_1) { 1 iload exec }
    (iload_2) { 2 iload exec }
    (iload_3) { 3 iload exec }
    (iadd) { iadd }
    (isub) { isub }
    (idivision) { idivision }
    (ireturn) { ireturn }
>> def

/ip 0 def

/load_byte { % -> string
    instructions ip get 
    /ip ip 1 add def 
} def

/load_inst_handler {
    userdict /instruction_handlers get exch 2 copy known not {
        (Encountered an unknown byte code instruction ') print print ('. Aborting.) print quit
    } if get
} def

/next { % -> the semantics of the next instruction will be applied
    load_byte 
    dup (Executing instruction ) print print (\n) print % logging
    load_inst_handler exec 
} def

/define_variables_for_parameters { % <input parameter> <parameter_count> ->
    % TODO: This counts in the wrong direction. Should count from <parameter_count> -> 0 instead of 0 -> <parameter_count>
    /i 0 def
    {
        //variables exch i exch put
        /i i 1 add def
    } repeat
} def

/execute { % <input parameters> <paramter_count> -> <result>
    define_variables_for_parameters
    { ip instructions length lt not { exit } if next } loop % loop until ip is after the last instruction
} def