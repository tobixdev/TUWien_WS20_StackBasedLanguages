/variables <<
>> def

% If the instruction has parameters (e.g. iload_0) the parameter will be on the top of the stack.
/instruction_handlers <<
    (goto) { load_byte load_byte goto }

    (if_icmplt) { load_byte load_byte if_icmplt }
    (if_icmpge) { load_byte load_byte if_icmpge }
    (ifeq) { load_byte load_byte ifeq }
    
    (iload) { load_byte iload }
    (iload_0) { 0 iload exec }
    (iload_1) { 1 iload exec }
    (iload_2) { 2 iload exec }
    (iload_3) { 3 iload exec }
    
    (iconst_m1) { -1 }
    (iconst_0) { 0 }
    (iconst_1) { 1 }
    (iconst_2) { 2 }
    (iconst_3) { 3 }
    (iconst_4) { 4 }
    (iconst_5) { 5 }
    
    (istore) { istore }
    (istore_0) { 0 istore }
    (istore_1) { 1 istore }
    (istore_2) { 2 istore }
    (istore_3) { 3 istore }
    
    (iadd) { iadd }
    (isub) { isub }
    (idiv) { idivision }
    (imul) { imult }
    
    (ireturn) { ireturn }
>> def

/ip 0 def

/load_byte { % -> string
    instructions ip get 
    /ip ip 1 add def 
} def

/load_inst_handler {
    userdict /instruction_handlers get exch 2 copy known not {
        (Encountered an unknown byte code instruction ') print print ('. Aborting.) print quit
    } if get
} def

/next { % -> the semantics of the next instruction will be applied
    load_byte 
    dup (Executing instruction ) print print (\n) print % logging
    load_inst_handler exec 
} def

/define_variables_for_parameters { % <input parameter> <parameter_count> ->
    % variables are numbered from <parameter_count> -1 -> 0
    dup 1 sub /pc_m1 exch def
    /i 0 def
    {
        //variables exch
        pc_m1 i sub
        exch put
        
        /i i 1 add def
    } repeat
} def

/execute { % <input parameters> <paramter_count> -> <result>
    define_variables_for_parameters
    { ip instructions length lt not { exit } if next } loop % loop until ip is after the last instruction
} def